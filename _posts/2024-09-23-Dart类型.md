---
title: Dart类型
date: 2024-9-23 09:39:34 +0800
categories:
  - dart
tags:
  - dart
  - flutter
description: 
math: true
---
> [Dart语言详解](https://rd-wang.github.io/posts/Dart基础概念和内部原理/)

# Dart 语言支持以下类型：

- Numbers(`int`, `double`)
- Strings (`String`)
- Booleans (`bool`)
- Records (`(value1, value2)`)
- Lists (`List`, also known as _arrays_)
- Sets (`Set`)
- Maps (`Map`)
- Runes (`Runes`; often replaced by the `characters` API)
- Symbols (`Symbol`)
- The value `null` (`Null`)

这些类型都可以被初始化为字面量。 例如, `'this is a string' `是一个字符串的字面量， `true` 是一个布尔的字面量。

由于 Dart 中的每个变量都引用一个对象（一个类的实例），所以变量可以使用构造函数进行初始化。 一些内置类型拥有自己的构造函数。 例如， 通过 `Map()` 来构造一个 map 变量。

其他一些类型在 Dart 语言中也有特殊作用：

- `Object`：除`Null`之外的所有 Dart 类的超类。
- `Enum`：所有枚举的超类。
- `Future`和`Stream`：用于异步支持。
- `Iterable`：用于for-in 循环和同步生成器函数。
- `Never`：表示表达式永远无法成功完成求值。最常用于总是抛出异常的函数。
- `dynamic`：表示要禁用静态检查。通常应使用`Object`或`Object?`代替。
- `void`：表示从未使用过该值。通常用作返回类型。

`Object`、`Object?`、`Null`和类在类层次结构中具有特殊角色。
# 基本类型
## Number
Dart 语言的 Number 有两种类型:

- int
整数值不大于64位， 具体取决于平台。
  - 在 Dart VM 上， 值的范围从 $-2 ^{63}$ 到 $2 ^{63} - 1$. 
  - 在 Web 上，整数值表示为 JavaScript 数字（没有小数部分的 64 位浮点值）, 值的范围从$-2 ^{53}$ 到 $2 ^{53} - 1$.

- double
64位（双精度）浮点数，依据 IEEE 754 标准。

`int `和 `double` 都是 `num`的子类。 num 类型包括基本运算 +， -， /， 和 *， 以及 `abs()`， `ceil()`， 和 `floor()`， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及子类找不到你想要的方法， 尝试查找使用 `dart:math` 库。

整数类型不包含小数点。
```dart
var x = 1;
var hex = 0xDEADBEEF;
```
如果数字包含小数，则它是双精度数。
```dart
var y = 1.1;
var exponents = 1.42e5;
```
还可以将变量声明为 num。如果这样做，变量可以同时具有整数和双精度值。
```dart
num x = 1; // x can have both int and double values
x += 2.5;
```
从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。

```dart
double z = 1; // 相当于 double z = 1.0.
```
>版本提示： 在 2.1 之前，在 double 上下文中使用 int 字面量是错误的。

以下是将字符串转换为数字的方法，反之亦然：
```dart
// String -> int
var one = int.parse('1');
assert(one == 1);

// String -> double
var onePointOne = double.parse('1.1');
assert(onePointOne == 1.1);

// int -> String
String oneAsString = 1.toString();
assert(oneAsString == '1');

// double -> String
String piAsString = 3.14159.toStringAsFixed(2);
assert(piAsString == '3.14');
```
`int`类型指定传统的位移位（`<<`, `>>`, `>>>`）、补码（`~`）、与（`&`）、或（`|`）和异或（`^`）运算符，这些运算符对于操作和屏蔽位字段中的标志很有用。
```dart
assert((3 << 1) == 6); // 0011 << 1 == 0110
assert((3 >> 1) == 1); // 0011 >> 1 == 0001
assert((3 | 4) == 7); // 0011 | 0100 == 0111
```
数字类型字面量是编译时常量。 在算术表达式中，只要参与计算的因子是编译时常量， 那么算术表达式的结果也是编译时常量。
```dart
const msPerSecond = 1000;
const secondsUntilRetry = 5;
const msUntilRetry = secondsUntilRetry * msPerSecond;
```
## String

Dart 字符串是一组（`String`对象） UTF-16 单元序列。 字符串通过单引号或者双引号创建。
```dart
var s1 = 'Single quotes work well for string literals.';
var s2 = "Double quotes work just as well.";
var s3 = 'It\'s easy to escape the string delimiter.';
var s4 = "It's even easier to use the other delimiter.";
```
字符串可以通过` ${expression}` 的方式内嵌表达式。 如果表达式是一个标识符，则 {} 可以省略。 在 Dart 中通过调用就对象的` toString() `方法来得到对象相应的字符串。
```dart
var s = 'string interpolation';

assert('Dart has $s, which is very handy.' ==
    'Dart has string interpolation, ' +
        'which is very handy.');
assert('That deserves all caps. ' +
        '${s.toUpperCase()} is very handy!' ==
    'That deserves all caps. ' +
        'STRING INTERPOLATION is very handy!');
```
>提示：如果两个字符串包含相同的代码单元序列，则它们是相等的。

使用相邻的字符串文字或`+` 运算符连接字符串：
```dart
var s1 = 'String '
    'concatenation'
    " works even over line breaks.";
assert(s1 ==
    'String concatenation works even over '
    'line breaks.');

var s2 = 'The + operator ' + 'works, as well.';
assert(s2 == 'The + operator works, as well.');
```
使用带有单引号或双引号的三重引号，创建多行字符串：
```dart
var s1 = '''
You can create
multi-line strings like this one.
''';

var s2 = """This is also a
multi-line string.""";
```
使用 r 前缀，可以创建 “原始 raw” 字符串：
```dart
var s = r'In a raw string, not even \n gets special treatment.';
```
参考 Runes 来了解如何在字符串中表达 Unicode 字符。

一个编译时常量的字面量字符串中，如果存在插值表达式，表达式内容也是编译时常量， 那么该字符串依旧是编译时常量。 插入的常量值类型可以是 null，数值，字符串或布尔值。
```dart
// const 类型数据
const aConstNum = 0;
const aConstBool = true;
const aConstString = 'a constant string';

// 非 const 类型数据
var aNum = 0;
var aBool = true;
var aString = 'a string';
const aConstList = [1, 2, 3];

const validConstString = '$aConstNum $aConstBool $aConstString'; //const 类型数据
// const invalidConstString = '$aNum $aBool $aString $aConstList'; //非 const 类型数据
```
更多关于 string 的使用, 参考 字符串和正则表达式.

## Boolean
Dart 使用 bool 类型表示布尔值。 Dart 只有字面量 `true `and `false` 是布尔类型， 这两个对象都是编译时常量。

Dart 的类型安全意味着不能使用` if (nonbooleanValue) `或者 `assert (nonbooleanValue)`。 而是应该像下面这样，明确的进行值检查：
```dart
// 检查空字符串。
var fullName = '';
assert(fullName.isEmpty);

// 检查 0 值。
var hitPoints = 0;
assert(hitPoints <= 0);

// 检查 null 值。
var unicorn;
assert(unicorn == null);

// 检查 NaN 。
var iMeantToDoThis = 0 / 0;
assert(iMeantToDoThis.isNaN);
```

## Rune
在 Dart 中， Rune 用来表示字符串中的 UTF-32 编码字符。

Unicode 为世界上所有书写系统中使用的每个字母、数字和符号定义了一个唯一的数值。由于 Dart 字符串是 UTF-16 代码单元的序列，因此在字符串中表达 Unicode 代码点需要特殊的语法。

表示 Unicode 编码的常用方法是，` \uXXXX`, 这里 XXXX 是一个4位的16进制数。 例如，心形符号 (♥) 是 \u2665。 要指定多于或少于 4 位十六进制数字，请将值放在花括号中。例如，笑脸表情符号 (😆) 为`\u{1f606}`。

如果需要读取或写入单个 Unicode 字符，使用`characters` 包在 String 上定义的characters getter。返回的`Characters`对象是作为字素簇序列的字符串。以下是使用 characters API 的示例：
```dart
import 'package:characters/characters.dart';

void main() {
  var hi = 'Hi 🇩🇰';
  print(hi);
  print('The end of the string: ${hi.substring(hi.length - 1)}');
  print('The last character: ${hi.characters.last}');
}
```

`String` 类有一些属性可以获得 rune 数据。 属性 `codeUnitAt` 和 `codeUnit` 返回16位编码数据。 属性` runes` 获取字符串中的 Rune 。

下面是示例演示了 Rune 、 16-bit code units、 和 32-bit code points 之间的关系。 
```dart
main() {
  var clapping = '\u{1f44f}';
  print(clapping);
  print(clapping.codeUnits);
  print(clapping.runes.toList());

  Runes input = new Runes(
      '\u2665  \u{1f605}  \u{1f60e}  \u{1f47b}  \u{1f596}  \u{1f44d}');
  print(new String.fromCharCodes(input));
}
```

👏
[55357, 56399]
[128079]
♥  😅  😎  👻  🖖  👍


>提示： 谨慎使用 list 方式操作 Rune 。 这种方法很容易引发崩溃， 具体原因取决于特定的语言，字符集和操作。 有关更多信息，参考[How do I reverse a String in Dart?](https://stackoverflow.com/questions/21521729/how-do-i-reverse-a-string-in-dart)  on Stack Overflow.

## Symbol
一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。
```dart
#radix
#bar
```
Symbol 字面量是编译时常量。
Symbol 详细请参阅：[Dart 反射](https://blog.csdn.net/rd_w_csdn/article/details/103926354)

# 集合（Collections）

## List
几乎每种编程语言中最常见的集合可能是数组，即有序的对象组。 在 Dart 中， *Array* 就是 `List` 对象， 通常称之为 List 。

Dart 中的 List 字面量由逗号分隔的表达式或值列表表示，括在方括号 ( `[]`) 中。 下面是一个 Dart List 的示例：
```dart
var list = [1, 2, 3];
```
>提示： Dart 推断 list 的类型为 List\<int> 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。 

Lists 的下标索引从 0 开始，第一个元素的索引是 0。 list.length - 1 是最后一个元素的索引。使用属性获取列表的长度，并使用下标运算符 ( )`.length`访问列表的值：`[]`
```dart
var list = [1, 2, 3];
assert(list.length == 3);
assert(list[1] == 2);

list[1] = 1;
assert(list[1] == 1);
```
在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：
```dart
var constantList = const [1, 2, 3];
// constantList[1] = 1; // 取消注释会引起错误。
```
List的一些常用API
```dart
var list = [1, 2, 3];
assert(list[1] == 2);

list.add(value);
list.addAll(iterable);
list.insert(index, element);
list.insertAll(index, iterable);

list.remove(2);
list.removeAt(1);
list.removeRange(0, 5);
list.removeLast();
list.clear();

list.indexOf(element);
list.lastIndexOf(element);

list.removeWhere((item) => item > 3);
list.sort((a, b) => a.compareTo(b));
var l = list.reversed;
list.isNotEmpty;
list.isEmpty;
list.length;

```
## Set
在 Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 `Set` 类型。

下面是通过字面量创建 Set 的一个简单示例：
```dart
var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};
```
>Note: Dart 推断 halogens 类型为 Set< String > 。如果尝试为它添加一个 错误类型的值，分析器或执行时会抛出错误。

要创建一个空集，使用前面带有类型参数的` {} `，或者将` {} `赋值给 Set 类型的变量：

```dart
var names = <String>{};
// Set<String> names = {}; // 这样也是可以的。
// var names = {}; // 这样会创建一个 Map ，而不是 Set 。
```

>是 Set 还是 Map ？ Map 字面量语法同 Set 字面量语法非常相似。 因为先有的 Map 字面量先出现，所以 {} 默认是 Map 类型。   如果忘记在 {} 上注释类型或赋值到一个未声明类型的变量上，   那么 Dart 会创建一个类型为 Map<dynamic, dynamic> 的对象。


使用 `add()` 或 `addAll()` 为已有的 Set 添加元素：
```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
```
使用 .length 来获取 Set 中元素的个数：
```dart
var elements = <String>{};
elements.add('fluorine');
elements.addAll(halogens);
assert(elements.length == 5);
```
在 Set 字面量前增加 const ，来创建一个编译时 Set 常量：
```dart
final constantSet = const {
  'fluorine',
  'chlorine',
  'bromine',
  'iodine',
  'astatine',
};
// constantSet.add('helium'); // Uncommenting this causes an error.
```
Set的一些常用API
```dart
var set = Set();
set.add(value);
set.addAll(elements);
set.remove(value);
set.removeAll(elements);
set.removeWhere((item)=>item>3);
set.contains(value);
set.containsAll(other);
set.isNotEmpty;
set.isEmpty;
set.length;
set.difference(other);//返回一个新集合，该集合的元素不在[other]中。
set.intersection(other);//返回一个新的集合，这个集合是这个集合和其他集合的交集。
set.union(other);//返回一个新的集合，其中包含这个集合和[其他]的所有元素。
```

## Map
通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。

下面是使用 Map 字面量的两个简单例子：
```dart
var gifts = {
  // Key:    Value
  'first': 'partridge',
  'second': 'turtledoves',
  'fifth': 'golden rings'
};

var nobleGases = {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};
```
>提示： Dart 会将 gifts 的类型推断为 Map<String, String>， nobleGases 的类型推断为 Map<int, String> 。 如果尝试在上面的 map 中添加错误类型，那么分析器或者运行时会引发错误。


以上 Map 对象也可以使用 Map 构造函数创建：
```dart
var gifts = Map();
gifts['first'] = 'partridge';
gifts['second'] = 'turtledoves';
gifts['fifth'] = 'golden rings';

var nobleGases = Map();
nobleGases[2] = 'helium';
nobleGases[10] = 'neon';
nobleGases[18] = 'argon';
```
提示: 这里为什么只有 `Map()` ，而不是使用 `new Map()`。 因为在 Dart 中，`new` 关键字是可选的。

使用下标赋值运算符 `[]=`( ) 向现有映射中添加新的键值对：
```dart
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds'; // Add a key-value pair
```
使用下标运算符 ( ) 从映射中检索值`[]`
```dart
var gifts = {'first': 'partridge'};
assert(gifts['first'] == 'partridge');
```
如果 Map 中不包含所要查找的 key，那么 Map 返回 null：
```dart
var gifts = {'first': 'partridge'};
assert(gifts['fifth'] == null);
```
使用 .length 获取当前 Map 中的 key-value 对数量：
```dart
var gifts = {'first': 'partridge'};
gifts['fourth'] = 'calling birds';
assert(gifts.length == 2);
```
创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。
```dart
final constantMap = const {
  2: 'helium',
  10: 'neon',
  18: 'argon',
};

// constantMap[2] = 'Helium'; // 取消注释会引起错误。
```
Map 常用API
```java
var map = {'first': 'partridge'};
map['fourth'] = 'calling birds';
map.remove(key);
map.addAll(other);
map.addEntries(newEntries);
map.putIfAbsent(key, ifAbsent);//查找[key]的值，如果没有，则添加一个新值。
map.remove(key);
map.removeWhere((key,value)=>{});
map.clear();
map.containsKey(key);
map.containsValue(value);
map.length;
map.isNotEmpty;
map.isEmpty;


```

## 控制流运算符

Dart 提供了**collection if** and **collection for** 供列表、映射和集合字面​​量使用. 您可以使用通过条件(`if`)和重复 (`for`)这些运算符构建集合。
**collection if**
```dart
var nav = ['Home', 'Furniture', 'Plants', if (promoActive) 'Outlet'];
```
**if-case**
```dart
var nav = ['Home', 'Furniture', 'Plants', if (login case 'Manager') 'Inventory'];
```
**collection for**
```dart
var listOfInts = [1, 2, 3];
var listOfStrings = ['#0', for (var i in listOfInts) '#$i'];
assert(listOfStrings[1] == '#1');
```

# 记录 (Records)
需要至少 3.0 的[语言版本](https://dart.cn/guides/language/evolution#language-versioning)

记录是一种匿名、不可变的聚合类型。与其他集合类型一样，它们允许将多个对象捆绑为一个对象。与其他集合类型不同，记录是固定大小、异构且类型化的。

记录是真实值；您可以将它们存储在变量中、嵌套它们、将它们传递到函数或从函数传递它们，以及将它们存储在列表、映射和集合等数据结构中。

## 记录语法
_记录表达式_ 是用逗号分隔的命名或位置字段列表，括在括号中：

```dart
var record = ('first', a: 2, b: true, 'last');
```
_记录类型注释_ 是用括号括起来的逗号分隔的类型列表。可以使用记录类型注释来定义返回类型和参数类型。例如，以下`(int, int)`语句是记录类型注释：

```dart
(int, int) swap((int, int) record) {
  var (a, b) = record;
  return (b, a);
}
```
记录表达式和类型注释中的字段反映了函数中参数和实参的工作方式。位置字段直接位于括号内：
```dart
// Record type annotation in a variable declaration:
(String, int) record;

// Initialize it with a record expression:
record = ('A string', 123);
```
在记录类型注释中，命名字段位于所有位置字段之后，位于类型和名称对的花括号分隔部分内。在记录表达式中，名称位于每个字段值之前，后面带有冒号：
```dart
// Record type annotation in a variable declaration:
({int a, bool b}) record;

// Initialize it with a record expression:
record = (a: 123, b: true);
```
记录类型中命名字段的名称是记录类型定义或其 _形状_ 的一部分。两个具有不同名称的命名字段的记录具有不同的类型：
```dart
({int a, int b}) recordAB = (a: 1, b: 2);
({int x, int y}) recordXY = (x: 3, y: 4);

// Compile error! These records don't have the same type.
// recordAB = recordXY;
```
在记录类型注释中，您还可以命名 _位置_ 字段，但这些名称纯粹用于文档，不会影响记录的类型：
```
(int a, int b) recordAB = (1, 2);
(int x, int y) recordXY = (3, 4);

recordAB = recordXY; // OK.
```
这类似于函数声明或函数 typedef 中的位置参数可以有名称，但这些名称不会影响函数的签名。

## 记录字段
记录字段可通过内置 getter 访问。记录是不可变的，因此字段没有 setter。
命名字段会公开同名的 getter。位置字段会公开名称为 的 getter `$<position>`，跳过命名字段：
```dart
var record = ('first', a: 2, b: true, 'last');

print(record.$1); // Prints 'first'
print(record.a); // Prints 2
print(record.b); // Prints true
print(record.$2); // Prints 'last'
```

## 记录类型

单个记录类型没有类型声明。记录根据其字段的类型进行结构化类型划分。记录的 _形状_（其字段集、字段类型及其名称（如果有））唯一地决定了记录的类型。

记录中的每个字段都有自己的类型。同一记录中的字段类型可能不同。无论从记录中访问哪个字段，类型系统都能识别每个字段的类型：

```dart
(num, Object) pair = (42, 'a');

var first = pair.$1; // Static type `num`, runtime type `int`.
var second = pair.$2; // Static type `Object`, runtime type `String`.
```
假设两个不相关的库创建了具有相同字段集的记录。即使库之间没有相互耦合，类型系统也会认为这些记录属于同一类型。

## 记录相等
如果两个记录具有相同的 _形状_ （字段集），并且其对应字段具有相同的值，则它们相等。由于命名字段 _顺序_ 不是记录形状的一部分，因此命名字段的顺序不会影响相等性。

```dart
(int x, int y, int z) point = (1, 2, 3);
(int r, int g, int b) color = (1, 2, 3);

print(point == color); // Prints 'true'.
```

```dart
({int x, int y, int z}) point = (x: 1, y: 2, z: 3);
({int r, int g, int b}) color = (r: 1, g: 2, b: 3);

print(point == color); // Prints 'false'. Lint: Equals on unrelated types.
```
记录会根据其字段的结构自动定义`hashCode`和方法。`==`

## 多次返回
记录允许函数返回捆绑在一起的多个值。要从返回中检索记录值， 使用模式匹配将值解构为局部变量。
```dart
// Returns multiple values in a record:
(String name, int age) userInfo(Map<String, dynamic> json) {
  return (json['name'] as String, json['age'] as int);
}

final json = <String, dynamic>{
  'name': 'Dash',
  'age': 10,
  'color': 'blue',
};

// Destructures using a record pattern with positional fields:
var (name, age) = userInfo(json);

/* Equivalent to:
  var info = userInfo(json);
  var name = info.$1;
  var age  = info.$2;
*/
```
您还可以使用冒号语法，通过其命名字段来解构记录
```dart
({String name, int age}) userInfo(Map<String, dynamic> json)
// ···
// Destructures using a record pattern with named fields:
final (:name, :age) = userInfo(json);
```
您可以从没有记录的函数返回多个值，但其他方法也有缺点。例如，创建一个类会更加冗长，而使用其他集合类型（如`List`或）`Map`会失去类型安全性。

# 泛型(Generics)

如果您查看基本数组类型的 API 文档，`List`您会发现该类型实际上是`List<E>`。 <...> 符号将 List 标记为  _通用_（或 _参数化_ ）类型 - 具有正式类型参数的类型。按照惯例，大多数类型变量都有单字母名称，例如 E、T、S、K 和 V。

## 为什么要使用泛型？

泛型通常是类型安全所必需的，但它们的好处不仅仅是让你的代码运行：
- 正确指定泛型类型可以生成更好的代码。
- 您可以使用泛型来减少代码重复。

如果您希望列表仅包含字符串，则可以将其声明为`List<String>`（读作“字符串列表”）。这样，您、您的程序员同事和您的工具就可以检测到将非字符串分配给列表可能是一个错误。以下是一个例子：

```dart
✗ 静态分析：失败
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
names.add(42); // Error
```
使用泛型的另一个原因是减少代码重复。泛型允许你在多种类型之间共享单个接口和实现，同时仍可利用静态分析。例如，假设你创建一个用于缓存对象的接口：
```dart
abstract class ObjectCache {
  Object getByKey(String key);
  void setByKey(String key, Object value);
}
```
您发现您需要该接口的字符串特定版本，因此您创建了另一个接口：
```dart
abstract class StringCache {
  String getByKey(String key);
  void setByKey(String key, String value);
}
```
稍后，您决定要使用这个界面的特定数字版本...您明白了。

泛型类型可以省去创建所有这些接口的麻烦。相反，你可以创建一个采用类型参数的接口：
```dart
abstract class Cache<T> {
  T getByKey(String key);
  void setByKey(String key, T value);
}
```
T 是替代类型。它是一个占位符，您可以将其视为开发人员稍后将定义的类型。

## 使用集合字面量
列表、集合和映射字面量可以参数化。参数化字面量就像您已经见过的字面量一样，只是您在左括号前添加了`<_type_>`（对于列表和集合）或 `<_keyType_, _valueType_>`（对于映射）。以下是使用类型字面量的示例：

```dart
var names = <String>['Seth', 'Kathy', 'Lars'];
var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};
var pages = <String, String>{
  'index.html': 'Homepage',
  'robots.txt': 'Hints for web robots',
  'humans.txt': 'We are people, not machines'
};
```
## 将参数化类型与构造函数一起使用
要在使用构造函数时指定一个或多个类型，请将类型放在类名后面的尖括号 (`<...>` ) 中。例如：
```dart
var nameSet = Set<String>.from(names);
```
以下代码创建一个具有整数键和 View 类型值的映射：

```dart
var views = Map<int, View>();
```

## 泛型集合及其包含的类型
Dart 泛型类型是 _具体化的_，这意味着它们在运行时会携带其类型信息。例如，您可以测试集合的类型：

```dart
var names = <String>[];
names.addAll(['Seth', 'Kathy', 'Lars']);
print(names is List<String>); // true
```
>相比之下，Java 中的泛型使用_擦除_，这意味着泛型类型参数在运行时被删除。在 Java 中，您可以测试一个对象是否是 List，但无法测试它是否是`List<String>`。

## 限制参数化类型
实现泛型类型时，您可能希望限制可以作为参数提供的类型，以便参数必须是特定类型的子类型。您可以使用`extends`来实现这一点。

一个常见的用例是确保类型不可空，通过使其成为的子类型`Object` （而不是默认的`Object?`）。
```dart
class Foo<T extends Object> {
  // Any type provided to Foo for T must be non-nullable.
}
```
可以将`extends`与除了`Object`之外的其他类型一起使用。这是扩展 SomeBaseClass 的示例，以便可以在`T`类型的对象上调用`SomeBaseClass`的成员：
```dart
class Foo<T extends SomeBaseClass> {
  // Implementation goes here...
  String toString() => "Instance of 'Foo<$T>'";
}

class Extender extends SomeBaseClass {...}
```
可以使用`SomeBaseClass`或其任何子类型作为泛型参数：
```dart
var someBaseClassFoo = Foo<SomeBaseClass>();
var extenderFoo = Foo<Extender>();
```
不指定通用参数也是可以的：
```dart
var foo = Foo();
print(foo); // Instance of 'Foo<SomeBaseClass>'
```
指定任何非`SomeBaseClass`类型都会导致错误：

```
✗ 静态分析：失败
var foo = Foo<Object>();
```
## 使用泛型方法
方法和函数也允许类型参数：
```dart
T first<T>(List<T> ts) {
  // Do some initial work or error checking, then...
  T tmp = ts[0];
  // Do some additional checking or processing...
  return tmp;
}
```
这里`first`(`T`)上的泛型类型参数允许您在多个地方使用类型参数`<T>`：

- 在函数的返回类型中（`T`）。
- 在参数类型中（`List<T>`）。
- 在局部变量的类型中（`T tmp`）。


# 别名 (Typedefs)

类型别名（通常称为_typedef_ ，因为它是用关键字声明的`typedef`）是一种引用类型的简洁方式。以下是声明和使用名为`IntList`的类型别名的示例：
```dart
typedef IntList = List<int>;
IntList il = [1, 2, 3];
```
类型别名可以有类型参数：
```dart
typedef ListMapper<X> = Map<X, List<X>>;
Map<String, List<String>> m1 = {}; // Verbose.
ListMapper<String> m2 = {}; // Same thing but shorter and clearer.
```
在大多数情况下，我们建议使用内联函数类型，而不是函数的 typedef。但是，函数 typedef 仍然有用：
```dart
typedef Compare<T> = int Function(T a, T b);

int sort(int a, int b) => a - b;

void main() {
  assert(sort is Compare<int>); // True!
}
```

