---
title: 基数排序
date: 2024-7-25 14:29:53 +0800
categories:
  - 排序算法
tags:
  - 排序
  - 算法
  - 基数排序
description: 基数排序（radix sort）的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。
math: true
---


# 基数排序

基数排序（Radix Sort）是一种非比较型整数排序算法。它通过将整数按位数分组排序，从最低有效位到最高有效位，或者从最高有效位到最低有效位，依次进行排序，从而实现最终的排序结果。

## 基数排序的原理

基数排序是一种稳定的排序算法，适用于整数排序。其主要思想是将整数按位数分组，从最低有效位开始，一次对每个位数进行计数排序（Counting Sort），最终得到有序数组。


### 两种实现方式

1. **LSD（Least Significant Digit）**：从最低有效位开始排序，逐步向最高有效位进行。
2. **MSD（Most Significant Digit）**：从最高有效位开始排序，逐步向最低有效位进行。

## 图示

![基数排序](https://rd-wang.github.io/assets/img/sort/基数排序.gif)

## 基数排序的步骤

1. **确定最大位数**：找到数组中最大数的位数，以确定需要进行几轮排序。
2. **逐位排序**：从最低有效位开始，对每个位进行计数排序。
3. **合并结果**：每次排序完成后，合并结果进行下一轮排序，直到所有位数排序完成。

## 示例

以下是一个基数排序的示例，假设我们有一个整数数组：[170, 45, 75, 90, 802, 24, 2, 66]。

### 第一步：确定最大位数

最大数是802，有3位，因此需要进行3轮排序。

### 第二步：逐位排序

- **第一轮**：按个位排序：
    
    - 输入：[170, 45, 75, 90, 802, 24, 2, 66]
    - 输出：[170, 90, 802, 2, 24, 45, 75, 66]
- **第二轮**：按十位排序：
    
    - 输入：[170, 90, 802, 2, 24, 45, 75, 66]
    - 输出：[802, 2, 24, 45, 66, 170, 75, 90]
- **第三轮**：按百位排序：
    
    - 输入：[802, 2, 24, 45, 66, 170, 75, 90]
    - 输出：[2, 24, 45, 66, 75, 90, 170, 802]

最终输出：[2, 24, 45, 66, 75, 90, 170, 802]


## 时间复杂度

- **最佳情况**：$O(nk)$  
- **最坏情况**：$O(nk)$ 
- **平均情况**：$O(nk)$ 
  
## 空间复杂度

- **空间复杂度**：$O(n + k)$。

## Java代码实现
```java
/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */
int digit(int num, int exp) {
    // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算
    return (num / exp) % 10;
}

/* 计数排序（根据 nums 第 k 位排序） */
void countingSortDigit(int[] nums, int exp) {
    // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组
    int[] counter = new int[10];
    int n = nums.length;
    // 统计 0~9 各数字的出现次数
    for (int i = 0; i < n; i++) {
        int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d
        counter[d]++;                // 统计数字 d 的出现次数
    }
    // 求前缀和，将“出现个数”转换为“数组索引”
    for (int i = 1; i < 10; i++) {
        counter[i] += counter[i - 1];
    }
    // 倒序遍历，根据桶内统计结果，将各元素填入 res
    int[] res = new int[n];
    for (int i = n - 1; i >= 0; i--) {
        int d = digit(nums[i], exp);
        int j = counter[d] - 1; // 获取 d 在数组中的索引 j
        res[j] = nums[i];       // 将当前元素填入索引 j
        counter[d]--;           // 将 d 的数量减 1
    }
    // 使用结果覆盖原数组 nums
    for (int i = 0; i < n; i++)
        nums[i] = res[i];
}

/* 基数排序 */
void radixSort(int[] nums) {
    // 获取数组的最大元素，用于判断最大位数
    int m = Integer.MIN_VALUE;
    for (int num : nums)
        if (num > m)
            m = num;
    // 按照从低位到高位的顺序遍历
    for (int exp = 1; exp <= m; exp *= 10) {
        // 对数组元素的第 k 位执行计数排序
        // k = 1 -> exp = 1
        // k = 2 -> exp = 10
        // 即 exp = 10^(k-1)
        countingSortDigit(nums, exp);
    }
}
```