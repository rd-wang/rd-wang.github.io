---
title: 桶排序
date: 2024-7-25 18:58:19 +0800
categories:
  - 排序算法
tags:
  - 排序
  - 算法
  - 桶排序
description: 桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。
math: true
---


# 桶排序

桶排序（Bucket Sort）是一种基于分配的排序算法。它将元素分散到不同的桶中，然后对每个桶分别进行排序，最后将桶中的元素合并起来。

## 桶排序的原理

桶排序适用于均匀分布在一定范围内的数值。其主要思想是：

1. **创建若干桶**：将要排序的数据分到若干个桶中。
2. **对每个桶内的数据进行排序**：桶内的排序可以使用任意排序算法。
3. **合并所有桶中的数据**：将排好序的桶中的数据合并，得到最终的有序数据。

## 桶排序的步骤

1. **创建桶**：根据数据范围和桶的数量，创建若干个桶。
2. **分配数据**：将数据分配到对应的桶中。
3. **桶内排序**：对每个桶中的数据进行排序。
4. **合并数据**：将所有桶中的数据按顺序合并，得到排序后的结果。

## 图示

![桶排序](https://rd-wang.github.io/assets/img/sort/桶排序.gif)


## 示例

以下是一个桶排序的示例，假设我们有一个浮点数数组：[0.42, 0.32, 0.23, 0.52, 0.25, 0.47, 0.51]。

### 第一步：创建桶

假设我们创建10个桶，每个桶对应范围是\[0, 0.1)，\[0.1, 0.2)，\[0.2, 0.3)等。

### 第二步：分配数据

将每个数据分配到对应的桶中：
- 0.42 -> 桶4
- 0.32 -> 桶3
- 0.23 -> 桶2
- 0.52 -> 桶5
- 0.25 -> 桶2
- 0.47 -> 桶4
- 0.51 -> 桶5

### 第三步：桶内排序

对每个桶中的数据进行排序：
- 桶2: [0.23, 0.25]
- 桶3: [0.32]
- 桶4: [0.42, 0.47]
- 桶5: [0.51, 0.52]

### 第四步：合并数据

将所有桶中的数据合并：[0.23, 0.25, 0.32, 0.42, 0.47, 0.51, 0.52]

## 复杂度分析

桶排序的时间复杂度取决于数据的分布情况和桶的数量。
一般来说，时间复杂度为：$O(n + k)$
其中：
- $n$是待排序元素的数量。
- $k$ 是桶的数量。

如果数据均匀分布且使用适当的排序算法，桶排序的时间复杂度接近 $O(n)$。

桶排序需要额外的空间来存储桶。其空间复杂度为：
$O(n + k)$
其中：
- $n$ 是待排序元素的数量。
- $k$ 是桶的数量。

## 时间复杂度

- **最佳情况**：$O(n)$。 
- **最坏情况**：$O(n^2)$。 
- **平均情况**：$O(n+k)$。
  
## 空间复杂度

- **空间复杂度**：$O(n \cdot k)$

## Java代码实现

```java
/* 桶排序 */
void bucketSort(float[] nums) {
    // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素
    int k = nums.length / 2;
    List<List<Float>> buckets = new ArrayList<>();
    for (int i = 0; i < k; i++) {
        buckets.add(new ArrayList<>());
    }
    // 1. 将数组元素分配到各个桶中
    for (float num : nums) {
        // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]
        int i = (int) (num * k);
        // 将 num 添加进桶 i
        buckets.get(i).add(num);
    }
    // 2. 对各个桶执行排序
    for (List<Float> bucket : buckets) {
        // 使用内置排序函数，也可以替换成其他排序算法
        Collections.sort(bucket);
    }
    // 3. 遍历桶合并结果
    int i = 0;
    for (List<Float> bucket : buckets) {
        for (float num : bucket) {
            nums[i++] = num;
        }
    }
}
```
