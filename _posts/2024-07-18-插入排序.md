---
title: 插入排序
date: 2024-7-18 16:21:37 +0800
categories:
  - 排序算法
tags:
  - 排序
  - 算法
  - 插入排序
description: 插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。
math: true
---

# 插入排序

插入排序（Insertion Sort）是一种简单直观的排序算法。它通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

## 工作原理

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

## 图示

![插入排序](https://rd-wang.github.io/assets/img/sort/插入排序.webp)

## 示例

假设有一个待排序的列表：[12, 11, 13, 5, 6]

### 第一步

- 第一个元素 12 已经排序。

### 第二步

- 取出 11，与 12 比较，11 小于 12，交换位置。
[11, 12, 13, 5, 6]

### 第三步

- 取出 13，与 12 比较，13 大于 12，不做交换。
[11, 12, 13, 5, 6]

### 第四步

- 取出 5，与 13 比较，5 小于 13，交换位置。
- 再与 12 比较，5 小于 12，交换位置。
- 再与 11 比较，5 小于 11，交换位置。
[5, 11, 12, 13, 6]

### 第五步

- 取出 6，与 13 比较，6 小于 13，交换位置。
- 再与 12 比较，6 小于 12，交换位置。
- 再与 11 比较，6 大于 5，不做交换。
[5, 6, 11, 12, 13]

## 复杂度分析

- **最坏情况时间复杂度**：$O(n^2)$
- **平均情况时间复杂度**：$O(n^2)$
- **最好情况时间复杂度**：$O(n)$
- **空间复杂度**：$O(1)$

如果目标是把n个元素的序列升序排列，那么采用**插入排序**存在最好情况和最坏情况。
- 最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需    $𝑛−1$ 次即可
- 最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 $\frac {1}{2}n(n-1)$ 次。
- **插入排序**的赋值操作是比较操作的次数减去$𝑛−1$次，（因为$𝑛−1$次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。
- 平均来说**插入排序**算法复杂度为 $O(n^{2})$。
  
**插入排序**不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么**插入排序**还是一个不错的选择。
插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。

## 代码实现

以下是插入排序的Java实现代码：

```java
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; ++i) {
            int key = arr[i];
            int j = i - 1;

            // 将 arr[0..i-1] 中大于 key 的元素向后移动一位
            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];
                j = j - 1;
            }
            arr[j + 1] = key;
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        for (int i : arr) {
            System.out.print(i + " ");
        }
    }
}
```

